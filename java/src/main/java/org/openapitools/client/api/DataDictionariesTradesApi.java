/*
 * OpenAPI definition
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.api;

import org.openapitools.client.ApiCallback;
import org.openapitools.client.ApiClient;
import org.openapitools.client.ApiException;
import org.openapitools.client.ApiResponse;
import org.openapitools.client.Configuration;
import org.openapitools.client.Pair;
import org.openapitools.client.ProgressRequestBody;
import org.openapitools.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import org.openapitools.client.model.PageWrapperAssetDto;
import org.openapitools.client.model.PageWrapperMarketVenueDto;
import org.openapitools.client.model.PageWrapperTradeMarketDto;
import org.openapitools.client.model.PageWrapperTradePairDto;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class DataDictionariesTradesApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public DataDictionariesTradesApi() {
        this(Configuration.getDefaultApiClient());
    }

    public DataDictionariesTradesApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    /**
     * Build call for tradeAssets
     * @param page Page number of items to start with (0..N) (optional, default to 0)
     * @param size Number of elements to return per page (optional, default to 1000)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call tradeAssetsCall(Integer page, Integer size, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/dictionaries/v2/trades/assets";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (page != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page", page));
        }

        if (size != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("size", size));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call tradeAssetsValidateBeforeCall(Integer page, Integer size, final ApiCallback _callback) throws ApiException {
        return tradeAssetsCall(page, size, _callback);

    }

    /**
     * Get assets
     * 
     * @param page Page number of items to start with (0..N) (optional, default to 0)
     * @param size Number of elements to return per page (optional, default to 1000)
     * @return PageWrapperAssetDto
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public PageWrapperAssetDto tradeAssets(Integer page, Integer size) throws ApiException {
        ApiResponse<PageWrapperAssetDto> localVarResp = tradeAssetsWithHttpInfo(page, size);
        return localVarResp.getData();
    }

    /**
     * Get assets
     * 
     * @param page Page number of items to start with (0..N) (optional, default to 0)
     * @param size Number of elements to return per page (optional, default to 1000)
     * @return ApiResponse&lt;PageWrapperAssetDto&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<PageWrapperAssetDto> tradeAssetsWithHttpInfo(Integer page, Integer size) throws ApiException {
        okhttp3.Call localVarCall = tradeAssetsValidateBeforeCall(page, size, null);
        Type localVarReturnType = new TypeToken<PageWrapperAssetDto>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get assets (asynchronously)
     * 
     * @param page Page number of items to start with (0..N) (optional, default to 0)
     * @param size Number of elements to return per page (optional, default to 1000)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call tradeAssetsAsync(Integer page, Integer size, final ApiCallback<PageWrapperAssetDto> _callback) throws ApiException {

        okhttp3.Call localVarCall = tradeAssetsValidateBeforeCall(page, size, _callback);
        Type localVarReturnType = new TypeToken<PageWrapperAssetDto>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for tradeMarketVenues
     * @param active Activity status filter. The market is considered inactive if we stop receiving messages for it. In case we receive a message from an inactive market, we flag it as active again. (optional)
     * @param page Page number of items to start with (0..N) (optional, default to 0)
     * @param size Number of elements to return per page (optional, default to 1000)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call tradeMarketVenuesCall(Boolean active, Integer page, Integer size, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/dictionaries/v2/trades/market-venues";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (active != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("active", active));
        }

        if (page != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page", page));
        }

        if (size != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("size", size));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call tradeMarketVenuesValidateBeforeCall(Boolean active, Integer page, Integer size, final ApiCallback _callback) throws ApiException {
        return tradeMarketVenuesCall(active, page, size, _callback);

    }

    /**
     * Get market-venues
     * 
     * @param active Activity status filter. The market is considered inactive if we stop receiving messages for it. In case we receive a message from an inactive market, we flag it as active again. (optional)
     * @param page Page number of items to start with (0..N) (optional, default to 0)
     * @param size Number of elements to return per page (optional, default to 1000)
     * @return PageWrapperMarketVenueDto
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public PageWrapperMarketVenueDto tradeMarketVenues(Boolean active, Integer page, Integer size) throws ApiException {
        ApiResponse<PageWrapperMarketVenueDto> localVarResp = tradeMarketVenuesWithHttpInfo(active, page, size);
        return localVarResp.getData();
    }

    /**
     * Get market-venues
     * 
     * @param active Activity status filter. The market is considered inactive if we stop receiving messages for it. In case we receive a message from an inactive market, we flag it as active again. (optional)
     * @param page Page number of items to start with (0..N) (optional, default to 0)
     * @param size Number of elements to return per page (optional, default to 1000)
     * @return ApiResponse&lt;PageWrapperMarketVenueDto&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<PageWrapperMarketVenueDto> tradeMarketVenuesWithHttpInfo(Boolean active, Integer page, Integer size) throws ApiException {
        okhttp3.Call localVarCall = tradeMarketVenuesValidateBeforeCall(active, page, size, null);
        Type localVarReturnType = new TypeToken<PageWrapperMarketVenueDto>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get market-venues (asynchronously)
     * 
     * @param active Activity status filter. The market is considered inactive if we stop receiving messages for it. In case we receive a message from an inactive market, we flag it as active again. (optional)
     * @param page Page number of items to start with (0..N) (optional, default to 0)
     * @param size Number of elements to return per page (optional, default to 1000)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call tradeMarketVenuesAsync(Boolean active, Integer page, Integer size, final ApiCallback<PageWrapperMarketVenueDto> _callback) throws ApiException {

        okhttp3.Call localVarCall = tradeMarketVenuesValidateBeforeCall(active, page, size, _callback);
        Type localVarReturnType = new TypeToken<PageWrapperMarketVenueDto>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for tradeMarkets
     * @param active Activity status filter. The market is considered inactive if we stop receiving messages for it. In case we receive a message from an inactive market, we flag it as active again. (optional)
     * @param symbol Asset symbol filter. The first listed currency of a currency pair, they are usually cryptocurrency tokens. The most diverse parameter (optional)
     * @param base Asset base filter. The second listed currency in the pair, also known as quote currency or counter currency. Usually fiat, stablecoin, or more popular crypto like BTC and ETH. The less diverse parameter (optional)
     * @param assetType Filter by type of the asset. Possible values are: &#39;spot&#39;, &#39;future&#39; or &#39;option&#39; (optional)
     * @param marketVenue Filter by market venue (optional)
     * @param pairId Filter by pair unique identifier (optional)
     * @param verbose Weather include pair details to response (optional, default to false)
     * @param page Page number of items to start with (0..N) (optional, default to 0)
     * @param size Number of elements to return per page (optional, default to 1000)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call tradeMarketsCall(Boolean active, String symbol, String base, String assetType, String marketVenue, String pairId, Boolean verbose, Integer page, Integer size, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/dictionaries/v2/trades/markets";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (active != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("active", active));
        }

        if (symbol != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("symbol", symbol));
        }

        if (base != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("base", base));
        }

        if (assetType != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("asset-type", assetType));
        }

        if (marketVenue != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("market-venue", marketVenue));
        }

        if (pairId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("pair-id", pairId));
        }

        if (verbose != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("verbose", verbose));
        }

        if (page != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page", page));
        }

        if (size != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("size", size));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call tradeMarketsValidateBeforeCall(Boolean active, String symbol, String base, String assetType, String marketVenue, String pairId, Boolean verbose, Integer page, Integer size, final ApiCallback _callback) throws ApiException {
        return tradeMarketsCall(active, symbol, base, assetType, marketVenue, pairId, verbose, page, size, _callback);

    }

    /**
     * Get markets
     * 
     * @param active Activity status filter. The market is considered inactive if we stop receiving messages for it. In case we receive a message from an inactive market, we flag it as active again. (optional)
     * @param symbol Asset symbol filter. The first listed currency of a currency pair, they are usually cryptocurrency tokens. The most diverse parameter (optional)
     * @param base Asset base filter. The second listed currency in the pair, also known as quote currency or counter currency. Usually fiat, stablecoin, or more popular crypto like BTC and ETH. The less diverse parameter (optional)
     * @param assetType Filter by type of the asset. Possible values are: &#39;spot&#39;, &#39;future&#39; or &#39;option&#39; (optional)
     * @param marketVenue Filter by market venue (optional)
     * @param pairId Filter by pair unique identifier (optional)
     * @param verbose Weather include pair details to response (optional, default to false)
     * @param page Page number of items to start with (0..N) (optional, default to 0)
     * @param size Number of elements to return per page (optional, default to 1000)
     * @return PageWrapperTradeMarketDto
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public PageWrapperTradeMarketDto tradeMarkets(Boolean active, String symbol, String base, String assetType, String marketVenue, String pairId, Boolean verbose, Integer page, Integer size) throws ApiException {
        ApiResponse<PageWrapperTradeMarketDto> localVarResp = tradeMarketsWithHttpInfo(active, symbol, base, assetType, marketVenue, pairId, verbose, page, size);
        return localVarResp.getData();
    }

    /**
     * Get markets
     * 
     * @param active Activity status filter. The market is considered inactive if we stop receiving messages for it. In case we receive a message from an inactive market, we flag it as active again. (optional)
     * @param symbol Asset symbol filter. The first listed currency of a currency pair, they are usually cryptocurrency tokens. The most diverse parameter (optional)
     * @param base Asset base filter. The second listed currency in the pair, also known as quote currency or counter currency. Usually fiat, stablecoin, or more popular crypto like BTC and ETH. The less diverse parameter (optional)
     * @param assetType Filter by type of the asset. Possible values are: &#39;spot&#39;, &#39;future&#39; or &#39;option&#39; (optional)
     * @param marketVenue Filter by market venue (optional)
     * @param pairId Filter by pair unique identifier (optional)
     * @param verbose Weather include pair details to response (optional, default to false)
     * @param page Page number of items to start with (0..N) (optional, default to 0)
     * @param size Number of elements to return per page (optional, default to 1000)
     * @return ApiResponse&lt;PageWrapperTradeMarketDto&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<PageWrapperTradeMarketDto> tradeMarketsWithHttpInfo(Boolean active, String symbol, String base, String assetType, String marketVenue, String pairId, Boolean verbose, Integer page, Integer size) throws ApiException {
        okhttp3.Call localVarCall = tradeMarketsValidateBeforeCall(active, symbol, base, assetType, marketVenue, pairId, verbose, page, size, null);
        Type localVarReturnType = new TypeToken<PageWrapperTradeMarketDto>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get markets (asynchronously)
     * 
     * @param active Activity status filter. The market is considered inactive if we stop receiving messages for it. In case we receive a message from an inactive market, we flag it as active again. (optional)
     * @param symbol Asset symbol filter. The first listed currency of a currency pair, they are usually cryptocurrency tokens. The most diverse parameter (optional)
     * @param base Asset base filter. The second listed currency in the pair, also known as quote currency or counter currency. Usually fiat, stablecoin, or more popular crypto like BTC and ETH. The less diverse parameter (optional)
     * @param assetType Filter by type of the asset. Possible values are: &#39;spot&#39;, &#39;future&#39; or &#39;option&#39; (optional)
     * @param marketVenue Filter by market venue (optional)
     * @param pairId Filter by pair unique identifier (optional)
     * @param verbose Weather include pair details to response (optional, default to false)
     * @param page Page number of items to start with (0..N) (optional, default to 0)
     * @param size Number of elements to return per page (optional, default to 1000)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call tradeMarketsAsync(Boolean active, String symbol, String base, String assetType, String marketVenue, String pairId, Boolean verbose, Integer page, Integer size, final ApiCallback<PageWrapperTradeMarketDto> _callback) throws ApiException {

        okhttp3.Call localVarCall = tradeMarketsValidateBeforeCall(active, symbol, base, assetType, marketVenue, pairId, verbose, page, size, _callback);
        Type localVarReturnType = new TypeToken<PageWrapperTradeMarketDto>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for tradePairs
     * @param active Activity status filter. The pair is considered inactive if we stop receiving messages for it. In case we receive a message from an inactive pair, we flag it as active again. (optional)
     * @param symbol Asset symbol filter. The first listed currency of a currency pair, they are usually cryptocurrency tokens. The most diverse parameter (optional)
     * @param base Asset base filter. The second listed currency in the pair, also known as quote currency or counter currency. Usually fiat, stablecoin, or more popular crypto like BTC and ETH. The less diverse parameter (optional)
     * @param assetType Filter by type of the asset. Possible values are: &#39;spot&#39;, &#39;future&#39; or &#39;option&#39; (optional)
     * @param page Page number of items to start with (0..N) (optional, default to 0)
     * @param size Number of elements to return per page (optional, default to 1000)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call tradePairsCall(Boolean active, String symbol, String base, String assetType, Integer page, Integer size, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/dictionaries/v2/trades/pairs";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (active != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("active", active));
        }

        if (symbol != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("symbol", symbol));
        }

        if (base != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("base", base));
        }

        if (assetType != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("asset-type", assetType));
        }

        if (page != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page", page));
        }

        if (size != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("size", size));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call tradePairsValidateBeforeCall(Boolean active, String symbol, String base, String assetType, Integer page, Integer size, final ApiCallback _callback) throws ApiException {
        return tradePairsCall(active, symbol, base, assetType, page, size, _callback);

    }

    /**
     * Get pairs
     * 
     * @param active Activity status filter. The pair is considered inactive if we stop receiving messages for it. In case we receive a message from an inactive pair, we flag it as active again. (optional)
     * @param symbol Asset symbol filter. The first listed currency of a currency pair, they are usually cryptocurrency tokens. The most diverse parameter (optional)
     * @param base Asset base filter. The second listed currency in the pair, also known as quote currency or counter currency. Usually fiat, stablecoin, or more popular crypto like BTC and ETH. The less diverse parameter (optional)
     * @param assetType Filter by type of the asset. Possible values are: &#39;spot&#39;, &#39;future&#39; or &#39;option&#39; (optional)
     * @param page Page number of items to start with (0..N) (optional, default to 0)
     * @param size Number of elements to return per page (optional, default to 1000)
     * @return PageWrapperTradePairDto
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public PageWrapperTradePairDto tradePairs(Boolean active, String symbol, String base, String assetType, Integer page, Integer size) throws ApiException {
        ApiResponse<PageWrapperTradePairDto> localVarResp = tradePairsWithHttpInfo(active, symbol, base, assetType, page, size);
        return localVarResp.getData();
    }

    /**
     * Get pairs
     * 
     * @param active Activity status filter. The pair is considered inactive if we stop receiving messages for it. In case we receive a message from an inactive pair, we flag it as active again. (optional)
     * @param symbol Asset symbol filter. The first listed currency of a currency pair, they are usually cryptocurrency tokens. The most diverse parameter (optional)
     * @param base Asset base filter. The second listed currency in the pair, also known as quote currency or counter currency. Usually fiat, stablecoin, or more popular crypto like BTC and ETH. The less diverse parameter (optional)
     * @param assetType Filter by type of the asset. Possible values are: &#39;spot&#39;, &#39;future&#39; or &#39;option&#39; (optional)
     * @param page Page number of items to start with (0..N) (optional, default to 0)
     * @param size Number of elements to return per page (optional, default to 1000)
     * @return ApiResponse&lt;PageWrapperTradePairDto&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<PageWrapperTradePairDto> tradePairsWithHttpInfo(Boolean active, String symbol, String base, String assetType, Integer page, Integer size) throws ApiException {
        okhttp3.Call localVarCall = tradePairsValidateBeforeCall(active, symbol, base, assetType, page, size, null);
        Type localVarReturnType = new TypeToken<PageWrapperTradePairDto>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get pairs (asynchronously)
     * 
     * @param active Activity status filter. The pair is considered inactive if we stop receiving messages for it. In case we receive a message from an inactive pair, we flag it as active again. (optional)
     * @param symbol Asset symbol filter. The first listed currency of a currency pair, they are usually cryptocurrency tokens. The most diverse parameter (optional)
     * @param base Asset base filter. The second listed currency in the pair, also known as quote currency or counter currency. Usually fiat, stablecoin, or more popular crypto like BTC and ETH. The less diverse parameter (optional)
     * @param assetType Filter by type of the asset. Possible values are: &#39;spot&#39;, &#39;future&#39; or &#39;option&#39; (optional)
     * @param page Page number of items to start with (0..N) (optional, default to 0)
     * @param size Number of elements to return per page (optional, default to 1000)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call tradePairsAsync(Boolean active, String symbol, String base, String assetType, Integer page, Integer size, final ApiCallback<PageWrapperTradePairDto> _callback) throws ApiException {

        okhttp3.Call localVarCall = tradePairsValidateBeforeCall(active, symbol, base, assetType, page, size, _callback);
        Type localVarReturnType = new TypeToken<PageWrapperTradePairDto>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
}
